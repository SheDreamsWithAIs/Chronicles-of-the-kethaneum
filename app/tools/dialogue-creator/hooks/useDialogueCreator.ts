/**
 * Main state management hook for dialogue creator
 */

import { useState, useCallback, useEffect } from 'react';
import type {
  Character,
  CharacterData,
  CharacterMetadata,
  BanterDialogue,
} from '@/lib/dialogue/types';
import type { ValidationResult, TextLimits } from '../types/creator.types';
import {
  getCharacterTemplate,
  getMetadataTemplate,
  getDialogueEntryTemplate,
} from '../utils/characterTemplate';
import { validateCharacter } from '../utils/validators';
import { exportCharacterToJSON } from '../utils/exportUtils';
import { generateCharacterIdFromName, isAutoGeneratedId } from '../utils/idGenerator';

interface DialogueCreatorState {
  character: Character;
  dialogueEntries: BanterDialogue[];
  metadata: CharacterMetadata;
  validationResults: ValidationResult[];
  isDirty: boolean;
  currentPreviewIndex: number;
  loadedCharacterId: string | null;
  textLimits: TextLimits | null;
  shouldValidate: boolean; // Only show validation errors after user interaction
}

export function useDialogueCreator() {
  const [state, setState] = useState<DialogueCreatorState>(() => ({
    character: getCharacterTemplate(),
    dialogueEntries: [],
    metadata: getMetadataTemplate(),
    validationResults: [],
    isDirty: false,
    currentPreviewIndex: 0,
    loadedCharacterId: null,
    textLimits: null,
    shouldValidate: false, // Don't validate until user interacts
  }));

  // Load text limits from config
  useEffect(() => {
    async function loadTextLimits() {
      try {
        const response = await fetch('/data/dialogue-config.json');
        if (response.ok) {
          const config = await response.json();
          setState(prev => ({
            ...prev,
            textLimits: config.display?.textLimits || null,
          }));
        }
      } catch (error) {
        console.error('Failed to load text limits:', error);
      }
    }
    loadTextLimits();
  }, []);

  // Auto-validate on changes (only if shouldValidate is true)
  useEffect(() => {
    if (!state.shouldValidate) {
      // Don't show validation errors until user has interacted
      return;
    }
    
    const results = validateCharacter(
      state.character,
      state.dialogueEntries,
      state.metadata,
      state.textLimits || undefined
    );
    setState(prev => ({ ...prev, validationResults: results }));
  }, [state.character, state.dialogueEntries, state.metadata, state.textLimits, state.shouldValidate]);

  // Character operations
  const updateCharacter = useCallback((field: keyof Character, value: any) => {
    setState(prev => {
      const newCharacter = { ...prev.character, [field]: value };

      // Auto-generate ID if name changed and ID was auto-generated
      if (field === 'name' && isAutoGeneratedId(prev.character.id, prev.character.name)) {
        newCharacter.id = generateCharacterIdFromName(value);
      }

      return {
        ...prev,
        character: newCharacter,
        isDirty: true,
        shouldValidate: true, // Start validating after first interaction
      };
    });
  }, []);

  // Dialogue operations
  const addDialogueEntry = useCallback(() => {
    setState(prev => {
      const existingIds = prev.dialogueEntries.map(d => d.id);
      const newEntry = getDialogueEntryTemplate(existingIds);
      return {
        ...prev,
        dialogueEntries: [...prev.dialogueEntries, newEntry],
        isDirty: true,
        shouldValidate: true, // Start validating after adding entry
      };
    });
  }, []);

  const updateDialogueEntry = useCallback((index: number, entry: BanterDialogue) => {
    setState(prev => ({
      ...prev,
      dialogueEntries: prev.dialogueEntries.map((e, i) => (i === index ? entry : e)),
      isDirty: true,
      shouldValidate: true, // Start validating after first interaction
    }));
  }, []);

  const deleteDialogueEntry = useCallback((index: number) => {
    setState(prev => ({
      ...prev,
      dialogueEntries: prev.dialogueEntries.filter((_, i) => i !== index),
      isDirty: true,
    }));
  }, []);

  const duplicateDialogueEntry = useCallback((index: number) => {
    setState(prev => {
      const entryToDuplicate = prev.dialogueEntries[index];
      const existingIds = prev.dialogueEntries.map(d => d.id);
      const newEntry: BanterDialogue = {
        ...entryToDuplicate,
        id: `${entryToDuplicate.id}-copy`,
      };

      // Ensure unique ID
      let counter = 1;
      while (existingIds.includes(newEntry.id)) {
        newEntry.id = `${entryToDuplicate.id}-copy-${counter}`;
        counter++;
      }

      return {
        ...prev,
        dialogueEntries: [
          ...prev.dialogueEntries.slice(0, index + 1),
          newEntry,
          ...prev.dialogueEntries.slice(index + 1),
        ],
        isDirty: true,
      };
    });
  }, []);

  const reorderDialogueEntry = useCallback(
    (index: number, direction: 'up' | 'down') => {
      const newIndex = direction === 'up' ? index - 1 : index + 1;

      setState(prev => {
        if (newIndex < 0 || newIndex >= prev.dialogueEntries.length) {
          return prev;
        }

        const entries = [...prev.dialogueEntries];
        [entries[index], entries[newIndex]] = [entries[newIndex], entries[index]];

        return {
          ...prev,
          dialogueEntries: entries,
          isDirty: true,
        };
      });
    },
    []
  );

  // Metadata operations
  const updateMetadata = useCallback((field: keyof CharacterMetadata, value: any) => {
    setState(prev => ({
      ...prev,
      metadata: { ...prev.metadata, [field]: value },
      isDirty: true,
      shouldValidate: true, // Start validating after first interaction
    }));
  }, []);

  // File operations
  const loadCharacter = useCallback(async (filename: string) => {
    try {
      const response = await fetch(`/api/manifest-manager/file?path=characters/${filename}`);
      if (!response.ok) {
        throw new Error(`Failed to load: ${response.status}`);
      }

      const data = await response.json();
      const characterData: CharacterData = data.content;

      setState({
        character: characterData.character,
        dialogueEntries: characterData.banterDialogue || [],
        metadata: characterData.metadata || getMetadataTemplate(),
        validationResults: [],
        isDirty: false,
        currentPreviewIndex: 0,
        loadedCharacterId: characterData.character.id,
        textLimits: state.textLimits,
        shouldValidate: false, // Don't validate loaded characters until user edits
      });
    } catch (error) {
      console.error('Error loading character:', error);
      throw error;
    }
  }, [state.textLimits]);

  const importFromJSON = useCallback((jsonString: string) => {
    try {
      const data: CharacterData = JSON.parse(jsonString);

      setState({
        character: data.character,
        dialogueEntries: data.banterDialogue || [],
        metadata: data.metadata || getMetadataTemplate(),
        validationResults: [],
        isDirty: true,
        currentPreviewIndex: 0,
        loadedCharacterId: data.character.id,
        textLimits: state.textLimits,
        shouldValidate: false, // Don't validate imported data until user edits
      });
    } catch (error) {
      console.error('Failed to parse JSON:', error);
      throw error;
    }
  }, [state.textLimits]);

  const exportToJSON = useCallback(() => {
    const characterData: CharacterData = {
      character: state.character,
      banterDialogue: state.dialogueEntries,
      metadata: {
        ...state.metadata,
        lastUpdated: new Date().toISOString().split('T')[0],
      },
    };

    const json = exportCharacterToJSON(characterData);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${state.character.id || 'character'}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }, [state]);

  const saveCharacter = useCallback(async () => {
    // Always validate before saving
    const results = validateCharacter(
      state.character,
      state.dialogueEntries,
      state.metadata,
      state.textLimits || undefined
    );

    const hasErrors = results.some(r => r.severity === 'error');
    if (hasErrors) {
      setState(prev => ({ 
        ...prev, 
        validationResults: results,
        shouldValidate: true, // Show validation errors on save attempt
      }));
      throw new Error('Please fix all errors before saving.');
    }

    const characterData: CharacterData = {
      character: state.character,
      banterDialogue: state.dialogueEntries,
      metadata: {
        ...state.metadata,
        lastUpdated: new Date().toISOString().split('T')[0],
      },
    };

    const filename = `${state.character.id}.json`;
    const filePath = `characters/${filename}`;
    const jsonContent = JSON.stringify(characterData, null, 2);

    const isNewCharacter = !state.loadedCharacterId;
    const characterIdChanged = state.loadedCharacterId && state.loadedCharacterId !== state.character.id;
    const oldFilename = state.loadedCharacterId ? `${state.loadedCharacterId}.json` : null;
    const oldFilePath = oldFilename ? `characters/${oldFilename}` : null;

    try {
      // If character ID changed, we need to create new file and delete old one
      if (characterIdChanged && oldFilePath) {
        // First, try to create the new file using POST
        const createResponse = await fetch('/api/manifest-manager/file', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filename: filename,
            contentType: 'object',
            currentPath: 'characters',
          }),
        });

        // If POST fails because file exists, or if it succeeds, update with PUT
        // (POST creates empty file, PUT updates it)
        const updateResponse = await fetch('/api/manifest-manager/file', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            path: filePath,
            content: jsonContent,
          }),
        });

        if (!updateResponse.ok) {
          const errorData = await updateResponse.json().catch(() => ({}));
          const errorMessage = errorData.error || `Failed to save character file (${updateResponse.status})`;
          throw new Error(errorMessage);
        }

        // Note: Old file is kept intentionally - user may want to keep both versions
      } else {
        // Normal save (new character or existing character with same ID)
        const saveResponse = await fetch('/api/manifest-manager/file', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            path: filePath,
            content: jsonContent,
          }),
        });

        if (!saveResponse.ok) {
          // If PUT fails because file doesn't exist, try POST then PUT
          if (saveResponse.status === 404 && isNewCharacter) {
            const createResponse = await fetch('/api/manifest-manager/file', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                filename: filename,
                contentType: 'object',
                currentPath: 'characters',
              }),
            });

            const updateResponse = await fetch('/api/manifest-manager/file', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                path: filePath,
                content: jsonContent,
              }),
            });

            if (!updateResponse.ok) {
              const errorData = await updateResponse.json().catch(() => ({}));
              const errorMessage = errorData.error || `Failed to save character file (${updateResponse.status})`;
              throw new Error(errorMessage);
            }
          } else {
            const errorData = await saveResponse.json().catch(() => ({}));
            const errorMessage = errorData.error || `Failed to save character file (${saveResponse.status})`;
            throw new Error(errorMessage);
          }
        }
      }

      // Update manifest if new character or character ID changed
      if (isNewCharacter || characterIdChanged) {
        try {
          const manifestResponse = await fetch('/api/manifest-manager/file?path=characters/character-manifest.json');
          if (manifestResponse.ok) {
            const manifestData = await manifestResponse.json();
            const manifest: string[] = manifestData.content || [];

            // If character ID changed, remove old filename from manifest
            if (characterIdChanged && oldFilename) {
              const oldIndex = manifest.indexOf(oldFilename);
              if (oldIndex !== -1) {
                manifest.splice(oldIndex, 1);
              }
            }

            // Add new filename if not already present
            if (!manifest.includes(filename)) {
              manifest.push(filename);
            }

            // Save updated manifest
            const manifestSaveResponse = await fetch('/api/manifest-manager/file', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                path: 'characters/character-manifest.json',
                content: JSON.stringify(manifest, null, 2),
              }),
            });

            if (!manifestSaveResponse.ok) {
              console.warn('Failed to update manifest');
            }
          }
        } catch (error) {
          console.warn('Failed to update manifest:', error);
          // Don't fail the save if manifest update fails
        }
      }

      setState(prev => ({ ...prev, isDirty: false, loadedCharacterId: prev.character.id }));
    } catch (error) {
      console.error('Failed to save character:', error);
      throw error;
    }
  }, [state]);

  const resetForm = useCallback(() => {
    if (state.isDirty && !confirm('Discard unsaved changes?')) {
      return;
    }

    setState({
      character: getCharacterTemplate(),
      dialogueEntries: [],
      metadata: getMetadataTemplate(),
      validationResults: [],
      isDirty: false,
      currentPreviewIndex: 0,
      loadedCharacterId: null,
      textLimits: state.textLimits,
      shouldValidate: false, // Reset validation state for new character
    });
  }, [state.isDirty, state.textLimits]);

  const validate = useCallback(() => {
    const results = validateCharacter(
      state.character,
      state.dialogueEntries,
      state.metadata,
      state.textLimits || undefined
    );
    setState(prev => ({ ...prev, validationResults: results }));
    return results;
  }, [state.character, state.dialogueEntries, state.metadata, state.textLimits]);

  const setPreviewIndex = useCallback((index: number) => {
    setState(prev => ({ ...prev, currentPreviewIndex: index }));
  }, []);

  return {
    ...state,
    updateCharacter,
    addDialogueEntry,
    updateDialogueEntry,
    deleteDialogueEntry,
    duplicateDialogueEntry,
    reorderDialogueEntry,
    updateMetadata,
    loadCharacter,
    importFromJSON,
    exportToJSON,
    saveCharacter,
    resetForm,
    validate,
    setPreviewIndex,
  };
}

